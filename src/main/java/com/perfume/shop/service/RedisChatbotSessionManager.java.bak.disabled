package com.perfume.shop.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.perfume.shop.dto.ConversationContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

/**
 * Redis-Backed Chatbot Session Manager
 * 
 * Handles:
 * - User conversation state persistence in Redis (not in-memory)
 * - Per-user context management
 * - Automatic session expiration after 24 hours of inactivity
 * - Thread-safe operations
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisChatbotSessionManager {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String CHATBOT_SESSION_KEY_PREFIX = "chatbot:session:";
    private static final String SESSION_TTL_HOURS = "24";
    private static final long SESSION_TIMEOUT_HOURS = 24L;
    
    /**
     * Store or update user's chatbot session in Redis
     * 
     * @param userId Unique user identifier
     * @param context Chatbot context object containing conversation state
     */
    public void storeSession(String userId, ConversationContext context) {
        try {
            String key = CHATBOT_SESSION_KEY_PREFIX + userId;
            
            // Store context in Redis with 24-hour TTL
            redisTemplate.opsForValue().set(
                    key,
                    context,
                    SESSION_TIMEOUT_HOURS,
                    TimeUnit.HOURS
            );
            
            log.debug("Chatbot session stored for user: {}", userId);
        } catch (Exception e) {
            log.error("Error storing chatbot session for user: {}", userId, e);
            throw new RuntimeException("Failed to store chatbot session", e);
        }
    }
    
    /**
     * Retrieve user's chatbot session from Redis
     * 
     * @param userId Unique user identifier
     * @return ConversationContext if exists, null otherwise
     */
    public ConversationContext getSession(String userId) {
        try {
            String key = CHATBOT_SESSION_KEY_PREFIX + userId;
            Object sessionData = redisTemplate.opsForValue().get(key);
            
            if (sessionData instanceof ConversationContext context) {
                log.debug("Chatbot session retrieved for user: {}", userId);
                return context;
            }
            
            return null;
            
        } catch (Exception e) {
            log.error("Error retrieving chatbot session for user: {}", userId, e);
            return null;
        }
    }
    
    /**
     * Clear user's chatbot session from Redis
     * 
     * @param userId Unique user identifier
     */
    public void clearSession(String userId) {
        try {
            String key = CHATBOT_SESSION_KEY_PREFIX + userId;
            Boolean deleted = redisTemplate.delete(key);
            
            if (deleted != null && deleted) {
                log.debug("Chatbot session cleared for user: {}", userId);
            }
        } catch (Exception e) {
            log.error("Error clearing chatbot session for user: {}", userId, e);
        }
    }
    
    /**
     * Check if session exists in Redis
     * 
     * @param userId Unique user identifier
     * @return true if session exists, false otherwise
     */
    public boolean sessionExists(String userId) {
        try {
            String key = CHATBOT_SESSION_KEY_PREFIX + userId;
            Boolean exists = redisTemplate.hasKey(key);
            return exists != null && exists;
        } catch (Exception e) {
            log.error("Error checking chatbot session existence for user: {}", userId, e);
            return false;
        }
    }
    
    /**
     * Refresh session TTL (extend session timeout)
     * Called when user is active in conversation
     * 
     * @param userId Unique user identifier
     */
    public void refreshSession(String userId) {
        try {
            String key = CHATBOT_SESSION_KEY_PREFIX + userId;
            redisTemplate.expire(key, SESSION_TIMEOUT_HOURS, TimeUnit.HOURS);
            log.debug("Chatbot session refreshed for user: {}", userId);
        } catch (Exception e) {
            log.error("Error refreshing chatbot session for user: {}", userId, e);
        }
    }
}
