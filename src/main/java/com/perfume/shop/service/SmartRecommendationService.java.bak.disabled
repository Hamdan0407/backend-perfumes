package com.perfume.shop.service;

import com.perfume.shop.dto.ProductResponse;
import com.perfume.shop.entity.Product;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Smart Recommendation Service
 * Provides intelligent fragrance recommendations based on user preferences and context
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class SmartRecommendationService {

    private final ProductService productService;

    /**
     * Get product recommendations based on user preferences
     */
    public List<ProductResponse> getRecommendations(
            String occasion,
            String scentType,
            Integer budgetMin,
            Integer budgetMax,
            String userCategory,
            int limit) {

        try {
            // Get all products
            List<Product> allProducts = productService.getAllProducts().stream()
                    .filter(p -> p.getActive() != null && p.getActive())
                    .collect(Collectors.toList());

            // Filter and score products
            List<Map.Entry<Product, Double>> scoredProducts = allProducts.stream()
                    .map(product -> new AbstractMap.SimpleEntry<>(
                            product,
                            scoreProduct(product, occasion, scentType, budgetMin, budgetMax, userCategory)
                    ))
                    .filter(entry -> entry.getValue() > 0)
                    .sorted((a, b) -> b.getValue().compareTo(a.getValue()))
                    .limit(limit)
                    .collect(Collectors.toList());

            return scoredProducts.stream()
                    .map(entry -> productService.convertToResponse(entry.getKey()))
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("Error generating recommendations", e);
            return new ArrayList<>();
        }
    }

    /**
     * Score product based on user preferences
     * Higher score = better match
     */
    private double scoreProduct(
            Product product,
            String occasion,
            String scentType,
            Integer budgetMin,
            Integer budgetMax,
            String userCategory) {

        double score = 0.0;

        // 1. Budget match (30%)
        if (budgetMin != null && budgetMax != null) {
            BigDecimal price = product.getPrice();
            if (price != null) {
                int productPrice = price.intValue();
                if (productPrice >= budgetMin && productPrice <= budgetMax) {
                    score += 30;
                } else if (productPrice < budgetMin) {
                    score += 15; // Partial credit for being cheaper
                } else if (productPrice > budgetMax) {
                    score += 0; // No credit for being too expensive
                }
            }
        }

        // 2. Category match (20%)
        if (userCategory != null && product.getCategory() != null) {
            if (product.getCategory().equalsIgnoreCase(userCategory)) {
                score += 20;
            } else if ("Unisex".equalsIgnoreCase(product.getCategory())) {
                score += 10; // Unisex works for anyone
            }
        }

        // 3. Fragrance notes match (25%)
        if (scentType != null && product.getFragranceNotes() != null) {
            List<String> notes = product.getFragranceNotes().stream()
                    .map(String::toLowerCase)
                    .collect(Collectors.toList());

            if (matchesScentType(scentType, notes)) {
                score += 25;
            } else if (notes.size() > 0) {
                score += 12; // Partial credit for having some notes
            }
        }

        // 4. Occasion match (15%)
        if (occasion != null && product.getDescription() != null) {
            String description = product.getDescription().toLowerCase();
            if (matchesOccasion(occasion, description)) {
                score += 15;
            }
        }

        // 5. Rating bonus (10%)
        if (product.getRating() != null && product.getRating() > 0) {
            // Rating out of 5, normalized to 0-10
            score += (product.getRating() / 5.0) * 10;
        }

        // 6. Popularity bonus (5%)
        if (product.getReviewCount() != null && product.getReviewCount() > 10) {
            score += 5;
        }

        return Math.min(score, 100); // Cap at 100
    }

    /**
     * Check if fragrance notes match scent type preference
     */
    private boolean matchesScentType(String scentType, List<String> notes) {
        String scentLower = scentType.toLowerCase();

        Map<String, List<String>> scentKeywords = Map.ofEntries(
                Map.entry("floral", Arrays.asList("rose", "jasmine", "lily", "peony", "gardenia", "mimosa", "violet")),
                Map.entry("woody", Arrays.asList("sandalwood", "cedarwood", "oud", "vetiver", "iris", "musk", "amber")),
                Map.entry("fresh", Arrays.asList("citrus", "lemon", "bergamot", "grapefruit", "lime", "mint", "green", "aqua")),
                Map.entry("oriental", Arrays.asList("vanilla", "amber", "incense", "patchouli", "tonka", "musk", "powdery")),
                Map.entry("fruity", Arrays.asList("apple", "peach", "plum", "berry", "strawberry", "raspberry", "pear", "mango")),
                Map.entry("spicy", Arrays.asList("cinnamon", "pepper", "clove", "nutmeg", "cardamom", "ginger")),
                Map.entry("citrus", Arrays.asList("lemon", "orange", "citrus", "bergamot", "lime", "grapefruit"))
        );

        List<String> keywords = scentKeywords.getOrDefault(scentLower, new ArrayList<>());
        return notes.stream()
                .anyMatch(note -> keywords.stream().anyMatch(note::contains));
    }

    /**
     * Check if product description matches occasion
     */
    private boolean matchesOccasion(String occasion, String description) {
        Map<String, List<String>> occasionKeywords = Map.ofEntries(
                Map.entry("work", Arrays.asList("professional", "office", "workplace", "business", "fresh", "light")),
                Map.entry("romantic", Arrays.asList("romantic", "date", "sensual", "seductive", "intimate", "passion")),
                Map.entry("casual", Arrays.asList("casual", "everyday", "daily", "light", "fresh", "comfortable")),
                Map.entry("party", Arrays.asList("party", "evening", "night", "celebration", "bold", "intense")),
                Map.entry("wedding", Arrays.asList("wedding", "celebration", "special", "elegant", "premium", "luxur")),
                Map.entry("beach", Arrays.asList("beach", "summer", "fresh", "citrus", "light", "marine"))
        );

        List<String> keywords = occasionKeywords.getOrDefault(occasion.toLowerCase(), new ArrayList<>());
        return keywords.stream().anyMatch(description::contains);
    }

    /**
     * Get products by price range
     */
    public List<ProductResponse> getProductsByPriceRange(int minPrice, int maxPrice, int limit) {
        try {
            List<Product> products = productService.getAllProducts().stream()
                    .filter(p -> p.getActive() != null && p.getActive())
                    .filter(p -> {
                        BigDecimal price = p.getPrice();
                        return price != null && price.intValue() >= minPrice && price.intValue() <= maxPrice;
                    })
                    .sorted((p1, p2) -> {
                        // Sort by rating first, then by recency
                        int ratingComp = p2.getRating().compareTo(p1.getRating());
                        return ratingComp != 0 ? ratingComp : p2.getId().compareTo(p1.getId());
                    })
                    .limit(limit)
                    .collect(Collectors.toList());

            return products.stream()
                    .map(productService::convertToResponse)
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("Error getting products by price range", e);
            return new ArrayList<>();
        }
    }

    /**
     * Get available products (in stock)
     */
    public List<ProductResponse> getAvailableProducts(int limit) {
        try {
            List<Product> products = productService.getAllProducts().stream()
                    .filter(p -> p.getActive() != null && p.getActive())
                    .filter(p -> p.getStock() != null && p.getStock() > 0)
                    .sorted((p1, p2) -> p2.getRating().compareTo(p1.getRating()))
                    .limit(limit)
                    .collect(Collectors.toList());

            return products.stream()
                    .map(productService::convertToResponse)
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("Error getting available products", e);
            return new ArrayList<>();
        }
    }

    /**
     * Get trending products (high rated, many reviews)
     */
    public List<ProductResponse> getTrendingProducts(int limit) {
        try {
            List<Product> products = productService.getAllProducts().stream()
                    .filter(p -> p.getActive() != null && p.getActive())
                    .filter(p -> p.getReviewCount() != null && p.getReviewCount() > 5)
                    .sorted((p1, p2) -> {
                        // Sort by review count, then by rating
                        int reviewComp = p2.getReviewCount().compareTo(p1.getReviewCount());
                        return reviewComp != 0 ? reviewComp : p2.getRating().compareTo(p1.getRating());
                    })
                    .limit(limit)
                    .collect(Collectors.toList());

            return products.stream()
                    .map(productService::convertToResponse)
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("Error getting trending products", e);
            return new ArrayList<>();
        }
    }
}
