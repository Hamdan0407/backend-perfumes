package com.perfume.shop.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Intent Detection Service
 * Identifies user intent from natural language queries
 * Supports: price queries, stock/availability checks, recommendations, product details
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class IntentDetectionService {

    public enum UserIntent {
        PRICE_QUERY("user asking for product price"),
        AVAILABILITY_CHECK("user asking about stock/availability"),
        PRODUCT_RECOMMENDATION("user asking for recommendations"),
        PRODUCT_COMPARISON("user comparing products"),
        OCCASION_QUERY("user asking for occasion-based suggestions"),
        SCENT_TYPE_QUERY("user asking about fragrance types"),
        BUDGET_QUERY("user asking about products in budget range"),
        GENERAL_CHAT("general conversation");
        
        private final String description;
        
        UserIntent(String description) {
            this.description = description;
        }
        
        public String getDescription() {
            return description;
        }
    }

    /**
     * Detect user intent from message
     */
    public UserIntent detectIntent(String userMessage) {
        if (userMessage == null || userMessage.trim().isEmpty()) {
            return UserIntent.GENERAL_CHAT;
        }

        String message = userMessage.toLowerCase().trim();

        // Price query patterns
        if (matchesPriceQuery(message)) {
            log.debug("Detected PRICE_QUERY intent");
            return UserIntent.PRICE_QUERY;
        }

        // Availability/Stock query patterns
        if (matchesAvailabilityQuery(message)) {
            log.debug("Detected AVAILABILITY_CHECK intent");
            return UserIntent.AVAILABILITY_CHECK;
        }

        // Recommendation patterns
        if (matchesRecommendationQuery(message)) {
            log.debug("Detected PRODUCT_RECOMMENDATION intent");
            return UserIntent.PRODUCT_RECOMMENDATION;
        }

        // Comparison patterns
        if (matchesComparisonQuery(message)) {
            log.debug("Detected PRODUCT_COMPARISON intent");
            return UserIntent.PRODUCT_COMPARISON;
        }

        // Occasion-based queries
        if (matchesOccasionQuery(message)) {
            log.debug("Detected OCCASION_QUERY intent");
            return UserIntent.OCCASION_QUERY;
        }

        // Scent type queries
        if (matchesScentTypeQuery(message)) {
            log.debug("Detected SCENT_TYPE_QUERY intent");
            return UserIntent.SCENT_TYPE_QUERY;
        }

        // Budget queries
        if (matchesBudgetQuery(message)) {
            log.debug("Detected BUDGET_QUERY intent");
            return UserIntent.BUDGET_QUERY;
        }

        log.debug("Defaulting to GENERAL_CHAT intent");
        return UserIntent.GENERAL_CHAT;
    }

    /**
     * Extract product name from message if present
     */
    public String extractProductName(String userMessage) {
        if (userMessage == null || userMessage.trim().isEmpty()) {
            return null;
        }

        String message = userMessage.toLowerCase().trim();

        // Pattern: "<brand/product> price" or "what is <product> price"
        Pattern productPattern = Pattern.compile("(?:price of|cost of|how much is|what is the price of|what's the price of)?\\s+([^?]+?)\\s+(?:price|cost|rupees|rs|₹)?\\??$");
        Matcher matcher = productPattern.matcher(message);
        
        if (matcher.find()) {
            String product = matcher.group(1).trim();
            // Remove common words
            product = product.replaceAll("\\b(the|a|an|is|are)\\b", "").trim();
            return product.isEmpty() ? null : product;
        }

        // Pattern: "<product> available" or "is <product> in stock"
        Pattern availabilityPattern = Pattern.compile("(?:is|are|is there)?\\s+([^?]+?)\\s+(?:available|in stock|in stock\\?|available\\?)");
        matcher = availabilityPattern.matcher(message);
        
        if (matcher.find()) {
            String product = matcher.group(1).trim();
            product = product.replaceAll("\\b(the|a|an|is|are)\\b", "").trim();
            return product.isEmpty() ? null : product;
        }

        return null;
    }

    /**
     * Extract budget range from message if present
     */
    public int[] extractBudgetRange(String userMessage) {
        if (userMessage == null || userMessage.trim().isEmpty()) {
            return null;
        }

        String message = userMessage.toLowerCase();

        // Pattern: "under 5000", "below 3000", "less than 4000"
        Pattern budgetPattern = Pattern.compile("(?:under|below|less than|up to)\\s+(\\d+)");
        Matcher matcher = budgetPattern.matcher(message);
        
        if (matcher.find()) {
            int maxBudget = Integer.parseInt(matcher.group(1));
            return new int[]{0, maxBudget};
        }

        // Pattern: "between 2000 and 5000"
        Pattern rangePatter = Pattern.compile("between\\s+(\\d+)\\s+(?:and|to)\\s+(\\d+)");
        matcher = rangePatter.matcher(message);
        
        if (matcher.find()) {
            int minBudget = Integer.parseInt(matcher.group(1));
            int maxBudget = Integer.parseInt(matcher.group(2));
            return new int[]{minBudget, maxBudget};
        }

        return null;
    }

    // ============= INTENT MATCHING PATTERNS =============

    private boolean matchesPriceQuery(String message) {
        return message.matches(".*(what|how much).*(?:price|cost|rupees|rs|₹).*") ||
               message.matches(".*(price|cost).*(?:of|for|gucci|dior|chanel|calvin|perfume).*") ||
               message.matches(".*(price|cost).*") && !message.contains("recommend") && !message.contains("suggest");
    }

    private boolean matchesAvailabilityQuery(String message) {
        return message.matches(".*(available|in stock|stock|availability|get).*") ||
               message.matches(".*(is|are).*(?:available|in stock).*");
    }

    private boolean matchesRecommendationQuery(String message) {
        return message.matches(".*(recommend|suggest|suggest me|what should|what would|best for|suitable for).*") ||
               message.matches(".*(which|what).*(?:perfume|fragrance|scent).*(?:for|do you recommend).*");
    }

    private boolean matchesComparisonQuery(String message) {
        return message.matches(".*(compare|vs|versus|difference|better|which is better).*") ||
               message.matches(".*(vs|v/s).*");
    }

    private boolean matchesOccasionQuery(String message) {
        return message.matches(".*(occasion|event|wedding|date|party|work|professional|casual|romantic).*") ||
               message.matches(".*(for what|for which).*(?:occasion|event).*");
    }

    private boolean matchesScentTypeQuery(String message) {
        return message.matches(".*(floral|woody|fresh|oriental|fruity|citrus|spicy|vanilla|musk|sandalwood|oud).*") ||
               message.matches(".*(type|kind|scent|fragrance).*");
    }

    private boolean matchesBudgetQuery(String message) {
        return message.matches(".*(budget|under|below|less than|afford|price range|up to|between).*") ||
               message.matches(".*(rupees|rs|₹).*");
    }
}
